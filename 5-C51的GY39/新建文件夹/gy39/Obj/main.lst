C51 COMPILER V9.54   MAIN                                                                  05/18/2023 13:39:34 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Obj\main.obj
COMPILER INVOKED BY: D:\software\Keil5\C51\BIN\C51.EXE User\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\App\24c02;.\App\iic
                    -;.\App\key;.\App\smg;.\Public;.\App\ds18b20;.\App\ds1302;.\App\ired;.\App\time;.\App\xpt2046;.\App\pwm;.\App\lcd1602) DE
                    -BUG OBJECTEXTEND PRINT(.\Obj\main.lst) OBJECT(.\Obj\main.obj)

line level    source

   1          /**************************************************************************************
   2          深圳市普中科技有限公司（PRECHIN 普中）
   3          技术支持：www.prechin.net
   4          
   5          实验名称：LCD1602液晶显示实验
   6          接线说明：      
   7          实验现象：下载程序后，LCD1602上显示字符信息
   8          注意事项：                                                                                                                                                                
   9          ***************************************************************************************/
  10          #include "public.h"
  11          #include "lcd1602.h"
  12          #include "stdio.h"
  13          #include "string.h"
  14          
  15          #define uint32_t unsigned long
  16          #define uint16_t unsigned int
  17          #define uint8_t unsigned char
  18             
  19          #define LED P1
  20          sbit Buzzer=P2^5;   //
  21          u8 buff1[3] = {0XA5,0x81,0x26};    // 光照
  22          u8 buff2[3] = {0XA5,0x82,0x27};
  23          u8 Receive_ok;
  24          u8 raw_data[15]={0};
  25          
  26          
  27          
  28          
  29          void uart_init(u8 baud)
  30          {
  31   1              TMOD|=0X20;     //设置计数器工作方式2
  32   1              SCON=0X50;      //设置为工作方式1
  33   1              PCON=0X80;      //波特率加倍
  34   1              TH1=baud;       //计数器初始值设置
  35   1              TL1=baud;
  36   1              ES=1;           //打开接收中断
  37   1              EA=1;           //打开总中断
  38   1              TR1=1;          //打开计数器            
  39   1      }
  40          
  41          void send_buff(u8 *tem_buff,u8 buff_size)
  42          {
  43   1          u8 i;
  44   1          for(i=0;i<buff_size;i++)
  45   1          {
  46   2              SBUF = tem_buff[i];
  47   2              while(TI==0){};
  48   2                              TI = 0;
  49   2          }
  50   1      }
  51          
  52          void main()
  53          {       
C51 COMPILER V9.54   MAIN                                                                  05/18/2023 13:39:34 PAGE 2   

  54   1                uint32_t TH_Light_min = 10;
  55   1                uint16_t temp;
  56   1                      uint32_t TH_Light_max = 80;
  57   1          uint16_t data_16[2]={0};
  58   1          uint32_t HUM,TE,Lux;
  59   1          u8 sum=0,i=0;
  60   1          uart_init(0XFA);//波特率为9600
  61   1              LCD_Init();//LCD1602初始化
  62   1      
  63   1              
  64   1              while(1)
  65   1              {
  66   2                      //===========================================
  67   2              send_buff(buff1,3);
  68   2                                      delay_ms(10);
  69   2                         if(Receive_ok==2)
  70   2              {
  71   3      
  72   3                  Lux = (raw_data[4]<<24)|(raw_data[5]<<16)|(raw_data[6]<<8)|raw_data[7];
  73   3                  LCD_ShowString(2,1,"Lux:");
  74   3                  LCD_ShowNum(2,5,Lux/100,3);
  75   3                  LCD_ShowString(2,8,".");
  76   3                  LCD_ShowNum(2,9,Lux%100,2);
  77   3                                              
  78   3                                                      if(Lux/100>TH_Light_max)
  79   3                                                      {
  80   4                                                                      temp = 300;
  81   4                                                      }
  82   3      //                                              else
  83   3      //                                              {
  84   3      //                                                      LCD_ShowNum(2,15,2,1);
  85   3      //                                                      Buzzer = 0;
  86   3      //                                              }
  87   3                                                      
  88   3                                                      if(Lux/100<TH_Light_min)
  89   3                                                      {
  90   4                                                               LED = 0x00;
  91   4                                                      }
  92   3                                                      else
  93   3                                                      {
  94   4                                                               LED = 0xff;
  95   4                                                      }
  96   3      
  97   3                                              
  98   3      
  99   3                                                      
 100   3                                              
 101   3                                                      
 102   3                  Receive_ok = 0;
 103   3              }
 104   2                                      delay_ms(500);
 105   2                      //=========================================
 106   2              send_buff(buff2,3);
 107   2                                      delay_ms(10);
 108   2              if(Receive_ok==1)
 109   2              {
 110   3      
 111   3                                                      HUM = (raw_data[10]<<8)|raw_data[11];
 112   3                                                      LCD_ShowString(1,1,"HU:");
 113   3                                                      LCD_ShowNum(1,4,HUM/100,2);
 114   3                                                      LCD_ShowString(1,6,".");
 115   3                                                      LCD_ShowNum(1,7,HUM%100,2);
C51 COMPILER V9.54   MAIN                                                                  05/18/2023 13:39:34 PAGE 3   

 116   3                                                      TE =(raw_data[4]<<8)|raw_data[5];
 117   3                                                      LCD_ShowString(1,9,"TE:");
 118   3                                                      LCD_ShowNum(1,12,TE/100,2);
 119   3                                                      LCD_ShowString(1,14,".");
 120   3                                                      LCD_ShowNum(1,15,TE%100,2);
 121   3      
 122   3                           
 123   3                  Receive_ok = 0;
 124   3              }
 125   2              delay_ms(500);
 126   2                                      
 127   2                              
 128   2                                      while(temp--)
 129   2                                      {
 130   3                                              Buzzer = !Buzzer;
 131   3                                              delay_10us(100);
 132   3                                      }
 133   2                                      temp = 0;
 134   2                                      Buzzer = 0;
 135   2                                      
 136   2              }       
 137   1      }
 138          
 139          
 140          //串口中断
 141          void USART_IRQHandler(void)interrupt 4
 142          {
 143   1              static uint8_t i=0,rebuf[15]={0};
 144   1              uint8_t sum=0;
 145   1         
 146   1          
 147   1          
 148   1              if(RI)//接收完成标志
 149   1              {
 150   2                      rebuf[i++]=SBUF;
 151   2              RI=0;//清中断接收标志
 152   2              
 153   2              
 154   2      //        SBUF = rebuf[i-1];
 155   2      //        while(!TI);           //等待发送数据完成
 156   2      //        TI=0;                 //清除发送完成标志位    
 157   2      //              
 158   2              
 159   2              
 160   2              
 161   2                      if (rebuf[0]!=0x5a)//帧头不对
 162   2                              i=0;    
 163   2                      if ((i==2)&&(rebuf[1]!=0x5a))//帧头不对
 164   2                              i=0;
 165   2              
 166   2                      if(i>3)//i等于4时，已经接收到数据量字节rebuf[3]
 167   2                      {
 168   3      
 169   3                              if(i!=(rebuf[3]+5))//判断是否接收一帧数据完毕
 170   3                                      return; 
 171   3                              switch(rebuf[2])//接收完毕后处理
 172   3                              {
 173   4                                      case 0x45:
 174   4                                              if(!Receive_ok)//当数据处理完成后才接收新的数据
 175   4                                              {
 176   5                                                      memcpy(raw_data,rebuf,15);//拷贝接收到的数据
 177   5                                                      Receive_ok=1;//接收完成标志
C51 COMPILER V9.54   MAIN                                                                  05/18/2023 13:39:34 PAGE 4   

 178   5      
 179   5                              
 180   5                                              }
 181   4                                              break;
 182   4                                      case 0x15:
 183   4                  if(!Receive_ok)//当数据处理完成后才接收新的数据
 184   4                                              {
 185   5                                                      memcpy(raw_data,rebuf,9);//拷贝接收到的数据
 186   5                                                      Receive_ok=2;//接收完成标志
 187   5                    
 188   5                                              }
 189   4                  break;//原始数据接收，可模仿0x45的方式
 190   4                                      case 0x35:break;
 191   4                              }
 192   3                              i=0;//缓存清0
 193   3                      }
 194   2              
 195   2              }
 196   1      
 197   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    808    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38      32
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
