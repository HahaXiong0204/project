C51 COMPILER V9.54   MAIN                                                                  05/20/2023 01:56:14 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Obj\main.obj
COMPILER INVOKED BY: D:\software\Keil5\C51\BIN\C51.EXE User\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\App\24c02;.\App\iic
                    -;.\App\key;.\App\smg;.\Public;.\App\ds18b20;.\App\ds1302;.\App\ired;.\App\time;.\App\xpt2046;.\App\pwm;.\App\lcd1602) DE
                    -BUG OBJECTEXTEND PRINT(.\Obj\main.lst) OBJECT(.\Obj\main.obj)

line level    source

   1          #include "public.h"
   2          #include "lcd1602.h"
   3          #include "stdio.h"
   4          #include "string.h"
   5          
   6          #define uint32_t unsigned long
   7          #define uint16_t unsigned int
   8          #define uint8_t unsigned char
   9             
  10          #define LED P1
  11          sbit Buzzer=P0^7;   //
  12          u8 buff1[3] = {0XA5,0x81,0x26};    // 光照
  13          u8 buff2[3] = {0XA5,0x82,0x27};
  14          u8 Receive_ok;
  15          u8 raw_data[15]={0};
  16          
  17          
  18          
  19          
  20          void uart_init(u8 baud)
  21          {
  22   1              TMOD|=0X20;     //设置计数器工作方式2
  23   1              SCON=0X50;      //设置为工作方式1
  24   1              PCON=0X80;      //波特率加倍
  25   1              TH1=baud;       //计数器初始值设置
  26   1              TL1=baud;
  27   1              ES=1;           //打开接收中断
  28   1              EA=1;           //打开总中断
  29   1              TR1=1;          //打开计数器            
  30   1      }
  31          
  32          void send_buff(u8 *tem_buff,u8 buff_size)
  33          {
  34   1          u8 i;
  35   1          for(i=0;i<buff_size;i++)
  36   1          {
  37   2              SBUF = tem_buff[i];
  38   2              while(TI==0){};
  39   2                              TI = 0;
  40   2          }
  41   1      }
  42          
  43          void main()
  44          {       
  45   1                uint32_t TH_Light_min = 10;
  46   1                      uint32_t TH_Light_max = 80;
  47   1          uint16_t data_16[2]={0};
  48   1          uint32_t HUM,TE,Lux;
  49   1          u8 sum=0,i=0;
  50   1          uart_init(0XFA);//波特率为9600
  51   1              LCD_Init();//LCD1602初始化
  52   1      
  53   1              
C51 COMPILER V9.54   MAIN                                                                  05/20/2023 01:56:14 PAGE 2   

  54   1              while(1)
  55   1              {
  56   2                      //===========================================
  57   2              send_buff(buff1,2);
  58   2                                      delay_ms(10);
  59   2                         if(Receive_ok==2)
  60   2              {
  61   3      
  62   3                  Lux = (raw_data[4]<<24)|(raw_data[5]<<16)|(raw_data[6]<<8)|raw_data[7];
  63   3                  LCD_ShowString(2,1,"Lux:");
  64   3                  LCD_ShowNum(2,5,Lux/100,3);
  65   3                  LCD_ShowString(2,8,".");
  66   3                  LCD_ShowNum(2,9,Lux%100,2);
  67   3      
  68   3                                              
  69   3      
  70   3                                                      
  71   3                                              
  72   3                                                      
  73   3                  Receive_ok = 0;
  74   3              }
  75   2                                      delay_ms(500);
  76   2                      //=========================================
  77   2              send_buff(buff1,3);
  78   2                                      delay_ms(10);
  79   2              if(Receive_ok==1)
  80   2              {
  81   3      
  82   3                                                      HUM = (raw_data[10]<<8)|raw_data[11];
  83   3                                                      LCD_ShowString(1,1,"HU:");
  84   3                                                      LCD_ShowNum(1,4,HUM/100,2);
  85   3                                                      LCD_ShowString(1,6,".");
  86   3                                                      LCD_ShowNum(1,7,HUM%100,2);
  87   3                                                      TE =(raw_data[4]<<8)|raw_data[5];
  88   3                                                      LCD_ShowString(1,9,"TE:");
  89   3                                                      LCD_ShowNum(1,12,TE/100,2);
  90   3                                                      LCD_ShowString(1,14,".");
  91   3                                                      LCD_ShowNum(1,15,TE%100,2);
  92   3      
  93   3                           
  94   3                  Receive_ok = 0;
  95   3              }
  96   2              delay_ms(500);
  97   2                      
  98   2              }       
  99   1      }
 100          
 101          
 102          //串口中断
 103          void USART_IRQHandler(void)interrupt 4
 104          {
 105   1              static uint8_t i=0,rebuf[15]={0};
 106   1              uint8_t sum=0;
 107   1         
 108   1          
 109   1          
 110   1              if(RI)//接收完成标志
 111   1              {
 112   2                      rebuf[i++]=SBUF;
 113   2              RI=0;//清中断接收标志
 114   2              
 115   2              
C51 COMPILER V9.54   MAIN                                                                  05/20/2023 01:56:14 PAGE 3   

 116   2      //        SBUF = rebuf[i-1];
 117   2      //        while(!TI);           //等待发送数据完成
 118   2      //        TI=0;                 //清除发送完成标志位    
 119   2      //              
 120   2              
 121   2              
 122   2              
 123   2                      if (rebuf[0]!=0x5a)//帧头不对
 124   2                              i=0;    
 125   2                      if ((i==2)&&(rebuf[1]!=0x5a))//帧头不对
 126   2                              i=0;
 127   2              
 128   2                      if(i>3)//i等于4时，已经接收到数据量字节rebuf[3]
 129   2                      {
 130   3      
 131   3                              if(i!=(rebuf[3]+5))//判断是否接收一帧数据完毕
 132   3                                      return; 
 133   3                              switch(rebuf[2])//接收完毕后处理
 134   3                              {
 135   4                                      case 0x45:
 136   4                                              if(!Receive_ok)//当数据处理完成后才接收新的数据
 137   4                                              {
 138   5                                                      memcpy(raw_data,rebuf,15);//拷贝接收到的数据
 139   5                                                      Receive_ok=1;//接收完成标志
 140   5      
 141   5                              
 142   5                                              }
 143   4                                              break;
 144   4                                      case 0x15:
 145   4                  if(!Receive_ok)//当数据处理完成后才接收新的数据
 146   4                                              {
 147   5                                                      memcpy(raw_data,rebuf,9);//拷贝接收到的数据
 148   5                                                      Receive_ok=2;//接收完成标志
 149   5                    
 150   5                                              }
 151   4                  break;//原始数据接收，可模仿0x45的方式
 152   4                                      case 0x35:break;
 153   4                              }
 154   3                              i=0;//缓存清0
 155   3                      }
 156   2              
 157   2              }
 158   1      
 159   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    695    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
